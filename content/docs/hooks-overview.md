---
id: hooks-overview
title: Hooks เดเดฑเตเดฑเดจเตเดเตเดเดคเตเดคเดฟเตฝ
permalink: docs/hooks-overview.html
next: hooks-state.html
prev: hooks-intro.html
---

React 16.8 เดฒเต เดชเตเดคเดฟเดฏเดคเดพเดฏเดฟ เดเตเตผเดเตเดเดชเตเดชเตเดเตเด เดซเตเดเตเดเตผ เดเดฃเต *Hooks*. เดเดคเต เดเดชเดฏเตเดเดฟเดเตเดเต class เดเดดเตเดคเดพเดคเต เดธเตเดฑเตเดฑเตเดฑเตเดฑเตเด เดฎเดฑเตเดฑเต เดฑเตเดฏเดพเดเตเดฑเตเดฑเต เดซเตเดเตเดเดฑเตเดเดณเตเด เดเดชเดฏเตเดเดฟเดเตเดเดพเดจเดพเดตเตเด.

Hooks [backwards-compatible](/docs/hooks-intro.html#no-breaking-changes) เดเดฃเต. เด เดเดฆเตเดงเตเดฏเดพเดฏเด เดชเดฐเดฟเดเตเดเดฏเดธเดฎเตเดชเดจเตเดจเดฐเดพเดฏ React เดกเตเดตเดฒเดชเตเดชเตเดดเตเดธเดฟเดจเต เดตเตเดฃเตเดเดฟ เดเดณเตเดณ เดตเตเดเดคเดฏเตเดฑเดฟเดฏ เดเดฐเต เดเดตเดฒเตเดเดจเดฎเดพเดฃเต. เดจเดฟเดเตเดเตพเดเตเดเต เดเดถเดฏเดเตเดเตเดดเดชเตเดชเด เดเดฃเตเดเตเดเตเดเดฟเตฝ, เดเดคเตเดชเตเดฒเตเดณเตเดณ เดเดฐเต เดฎเดเตเด เดฌเตเดเตเดธเดฟเดจเดพเดฏเดฟ เดจเตเดเตเดเตเด

>เดตเดฟเดถเดฆเตเดเดฐเดฃเด
>
>Hooks เดเดจเตเดคเต เดเตเดฃเตเดเต เดเตพเดชเตเดชเตเดเตเดคเตเดคเตเดจเตเดจเต เดเดจเตเดจเต เดเดฑเดฟเดฏเตเดตเดพเตป [เดชเตเดฐเดเตเดฆเดจเด](/docs/hooks-intro.html#motivation) เดตเดพเดฏเดฟเดเตเดเดพเด 

**โโโ เดเดฐเต เดตเดฟเดญเดพเดเดตเตเด เดเดคเตเดชเตเดฒเตเดฐเต เดฎเดเตเด เดฌเตเดเตเดธเดฟเดฒเดพเดฃเต เดเดตเดธเดพเดจเดฟเดเตเดเตเดจเตเดจเดคเต. เดเดตเตผ เดตเดฟเดถเดฆเดฎเดพเดฏ เดตเดฟเดตเดฐเดฃเดเตเดเดณเตเดฎเดพเดฏเดฟ เดฌเดจเตเดงเดชเตเดชเตเดเตเดเดฟเดฐเดฟเดเตเดเตเดจเตเดจเต.

## ๐ State Hook {#state-hook}

เด เดเดฆเดพเดนเดฐเดฃเดคเตเดคเดฟเตฝ เดเดฐเต เดเตเดฃเตเดเตผ เดเดฃเตเดเดพเดเตเดจเตเดจเดคเต เดเดเตเดเดจเต เดเดจเตเดจเต เดเดพเดฃเดพเด. เดฌเดเตเดเตบ เดเดฎเตผเดคเตเดคเดฟเดฏเดพเตฝ เดเดชเตเดชเตเตพ เดเดณเตเดณ เดฎเตเดฒเตเดฏเด เดเดจเตเดจเต เดตเตเดคเด เดเตเดเตเด:

```js{1,4,5}
import React, { useState } from 'react';

function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

เดเดตเดฟเดเต เดจเดฎเตเดฎเตพ เดเดชเดฏเตเดเดฟเดเตเดเตเดจเตเดจเดคเต useState เดเดจเตเดจ Hook เดเดฃเต. Hook เดเดจเตเดจเดคเต เดเตเดฃเตเดเต  เดเดเตเดจเตเดจเดคเต เดเดจเตเดจเต เดคเดพเดดเต เดเดพเดฃเดพเด. functional component เดฒเตเดเต state เดเตเดฃเตเดเต เดตเดฐเดพเตป เดเดฃเต เด hook เดเดชเดฏเตเดเดฟเดเตเดเตเดจเตเดจเดคเต. re-render เดเตพเดเตเดเต เดเดเดฏเดฟเดฒเตเด React เด state เดจเตเดฑเต เดฎเตเดฒเตเดฏเด เดฎเดพเดฑเดพเดคเต เดธเตเดเตเดทเดฟเดเตเดเตเด. useState function เดคเดฟเดฐเดฟเดเต เดคเดฐเตเดจเตเดจเดคเต เดฐเดฃเตเดเต เดเดพเดฐเตเดฏเดเตเดเตพ เดเดฃเต: เดเดชเตเดชเตเตพ เดเดณเตเดณ state เดจเตเดฑเต เดฎเตเดฒเตเดฏเดตเตเด, เด เดฎเตเดฒเตเดฏเดคเตเดคเต เดฎเดพเดฑเตเดฑเตเดตเดพเตป เดเดณเตเดณ function เดเด. เดจเดฟเดเตเดเตพเดเตเดเต เด function เดเดฐเต event handler เตฝ เดจเดฟเดจเตเดจเต, เดฎเดฑเตเดฑเต เดเดตเดฟเดเต เดจเดฟเดจเตเดจเต เดตเดฟเดณเดฟเดเตเดเดพเดตเตเดจเตเดจเดคเต เดเดฃเต. เดชเตเดคเดฟเดฏเดคเตเด เดชเดดเดฏเดคเตเด เดเดฏ เดเตเดเตเดเดฟเดเตเดเตเตผเดเตเดเตเดจเตเดจเดฟเดฒเตเดฒ เดเดจเตเดจเดคเต เดเดดเดฟเดเตเดเดพเตฝ class components เตฝ เดจเดฎเตเดฎเตพ เดเดชเดฏเตเดเดฟเดเตเดเตเดจเตเดจ  `this.setState` เดชเตเดฒเต เดเดฃเต เดเดคเต เดชเตเดฐเดตเตผเดคเตเดคเดฟเดเตเดเตเดจเตเดจเดคเต. (เดเดต เดฐเดฃเตเดเตเด เดคเดพเดฐเดคเดฎเตเดฏเดชเตเดชเตเดเตเดคเตเดคเตเดจเตเดจ เดเดฐเต เดเดฆเตเดงเดฐเดนเดพเดฐเด [Using the State Hook](/docs/hooks-state.html) เดเดจเตเดจ เดเดฆเตเดงเตเดฏเดพเดฏเดคเตเดคเดฟเตฝ เดเดพเดฃเดพเด.)

`useState` function เดจเตเดฑเต เดเดฐเต เดเดฐเต argument state เดจเตเดฑเต เดคเตเดเดเตเดเดคเตเดคเดฟเตฝ เดเดณเตเดณ เดฎเตเดฒเตเดฏเด เดเดฃเต. เดจเดฎเตเดฎเตพ เดฎเตเดเดณเดฟเตฝ เดเตเดเตเดคเตเดค เดเดฆเดพเดนเดฐเดฃเดคเตเดคเดฟเตฝ เดเดคเต `0` เดเดฃเต, เดเดพเดฐเดฃเด เดจเดฎเตเดฎเดณเตเดเต เดเตเดฃเตเดเตผ เดชเตเดเตเดฏเดคเตเดคเดฟเตฝ เดจเดฟเดจเตเดจเต เดเดฃเต เดคเตเดเดเตเดเตเดจเตเดจเดคเต. `this.state`เดเดจเตเดจเดคเดฟเตฝ เดจเดฟเดจเตเดจเต เดตเดคเตเดฏเดพเดธเด เดเดฏเดฟ state เดเดตเดฟเดเต เดเดฐเต object เดเดเดฃเด เดเดจเตเดจเต เดจเดฟเตผเดฌเดจเตเดงเด เดเดฒเตเดฒ. เดเดฆเตเดฏเดคเตเดคเต render เตฝ เดฎเดพเดคเตเดฐเดฎเต เดคเตเดเดเตเดเดคเตเดคเดฟเตฝ เดเตเดเตเดเตเดเตเดจเตเดจ เดฎเตเดฒเตเดฏเด เดเดชเดฏเตเดเดฟเดเตเดเตเด เดเดณเตเดณเต .

#### Declaring multiple state variables {#declaring-multiple-state-variables}

เดเดฐเต component เตฝ เดคเดจเตเดจเต เดชเดฒ เดคเดตเดฃ State Hook เดเดชเดฏเตเดเดฟเดเตเดเดพเตป เดเดตเตเด:

```js
function ExampleWithManyStates() {
  // Declare multiple state variables!
  const [age, setAge] = useState(42);
  const [fruit, setFruit] = useState('banana');
  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);
  // ...
}
```

[array destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring) เดเดจเตเดจเต เดเดฑเดฟเดฏเดชเตเดชเตเดเตเดจเตเดจ เดธเดฟเดจเตเดฑเดพเดธเตโ เดเดชเดฏเตเดเดฟเดเตเดเต เดจเดฎเตเดเตเดเต เดคเดฟเดฐเดฟเดเตเดเต เดเดฟเดเตเดเตเดจเตเดจ array เตฝ เดเดณเตเดณ เดฎเตเดฒเตเดฏเดเตเดเตพเดเตเดเต เดชเดฒ เดชเตเดฐเตเดเตพ เดเตเดเตเดเตเดเดพเด. เด เดชเตเดฐเตเดเตพ `useState` function เดเด เดเดฏเดฟ เดฌเดจเตเดงเดชเตเดเตเดเต เดตเดฐเตเดจเตเดจเดคเต เดเดฒเตเดฒ. เดเดคเดฟเดจเต เดชเดเดฐเด เดจเดฟเดเตเดเตพ `useState` เดตเดฟเดณเดฟเดเตเดเตเดฎเตเดชเตเดดเตเดฒเตเดฒเดพเด เดเดฐเต เดเตเดฐเดฎเดคเตเดคเดฟเตฝ เดเดฃเต เดตเดฟเดณเดฟเดเตเดเตเดจเตเดจเดคเต เดเดจเตเดจเต React เดเดจเตเดฎเดพเดจเดฟเดเตเดเตเด. เดเดคเต เดเดจเตเดคเต เดเตเดฃเตเดเต เดเดเตเดเดจเต เดชเตเดฐเดตเตผเดคเตเดคเดฟเดเตเดเตเดจเตเดจเดคเต เดเดจเตเดจเต เดจเดฎเตเดเตเดเต เดชเดฟเดจเตเดเต เดเดพเดฃเดพเด. 

#### But what is a Hook? {#but-what-is-a-hook}

Hooks are functions that let you โhook intoโ React state and lifecycle features from function components. Hooks don't work inside classes -- they let you use React without classes. (We [don't recommend](/docs/hooks-intro.html#gradual-adoption-strategy) rewriting your existing components overnight but you can start using Hooks in the new ones if you'd like.)

React provides a few built-in Hooks like `useState`. You can also create your own Hooks to reuse stateful behavior between different components. We'll look at the built-in Hooks first.

>Detailed Explanation
>
>You can learn more about the State Hook on a dedicated page: [Using the State Hook](/docs/hooks-state.html).

## โก๏ธ Effect Hook {#effect-hook}

You've likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations "side effects" (or "effects" for short) because they can affect other components and can't be done during rendering.

The Effect Hook, `useEffect`, adds the ability to perform side effects from a function component. It serves the same purpose as `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` in React classes, but unified into a single API. (We'll show examples comparing `useEffect` to these methods in [Using the Effect Hook](/docs/hooks-effect.html).)

For example, this component sets the document title after React updates the DOM:

```js{1,6-10}
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // Similar to componentDidMount and componentDidUpdate:
  useEffect(() => {
    // Update the document title using the browser API
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

When you call `useEffect`, you're telling React to run your "effect" function after flushing changes to the DOM. Effects are declared inside the component so they have access to its props and state. By default, React runs the effects after every render -- *including* the first render. (We'll talk more about how this compares to class lifecycles in [Using the Effect Hook](/docs/hooks-effect.html).)

Effects may also optionally specify how to "clean up" after them by returning a function. For example, this component uses an effect to subscribe to a friend's online status, and cleans up by unsubscribing from it:

```js{10-16}
import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);

    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Loading...';
  }
  return isOnline ? 'Online' : 'Offline';
}
```

In this example, React would unsubscribe from our `ChatAPI` when the component unmounts, as well as before re-running the effect due to a subsequent render. (If you want, there's a way to [tell React to skip re-subscribing](/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects) if the `props.friend.id` we passed to `ChatAPI` didnโt change.)

Just like with `useState`, you can use more than a single effect in a component:

```js{3,8}
function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }
  // ...
```

Hooks let you organize side effects in a component by what pieces are related (such as adding and removing a subscription), rather than forcing a split based on lifecycle methods.

>Detailed Explanation
>
>You can learn more about `useEffect` on a dedicated page: [Using the Effect Hook](/docs/hooks-effect.html).

## โ๏ธ Rules of Hooks {#rules-of-hooks}

Hooks are JavaScript functions, but they impose two additional rules:

* Only call Hooks **at the top level**. Donโt call Hooks inside loops, conditions, or nested functions.
* Only call Hooks **from React function components**. Donโt call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks -- your own custom Hooks. We'll learn about them in a moment.)

We provide a [linter plugin](https://www.npmjs.com/package/eslint-plugin-react-hooks) to enforce these rules automatically. We understand these rules might seem limiting or confusing at first, but they are essential to making Hooks work well.

>Detailed Explanation
>
>You can learn more about these rules on a dedicated page: [Rules of Hooks](/docs/hooks-rules.html).

## ๐ก Building Your Own Hooks {#building-your-own-hooks}

Sometimes, we want to reuse some stateful logic between components. Traditionally, there were two popular solutions to this problem: [higher-order components](/docs/higher-order-components.html) and [render props](/docs/render-props.html). Custom Hooks let you do this, but without adding more components to your tree.

Earlier on this page, we introduced a `FriendStatus` component that calls the `useState` and `useEffect` Hooks to subscribe to a friend's online status. Let's say we also want to reuse this subscription logic in another component.

First, we'll extract this logic into a custom Hook called `useFriendStatus`:

```js{3}
import React, { useState, useEffect } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}
```

It takes `friendID` as an argument, and returns whether our friend is online.

Now we can use it from both components:


```js{2}
function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);

  if (isOnline === null) {
    return 'Loading...';
  }
  return isOnline ? 'Online' : 'Offline';
}
```

```js{2}
function FriendListItem(props) {
  const isOnline = useFriendStatus(props.friend.id);

  return (
    <li style={{ color: isOnline ? 'green' : 'black' }}>
      {props.friend.name}
    </li>
  );
}
```

The state of these components is completely independent. Hooks are a way to reuse *stateful logic*, not state itself. In fact, each *call* to a Hook has a completely isolated state -- so you can even use the same custom Hook twice in one component.

Custom Hooks are more of a convention than a feature. If a function's name starts with "`use`" and it calls other Hooks, we say it is a custom Hook. The `useSomething` naming convention is how our linter plugin is able to find bugs in the code using Hooks.

You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven't considered. We are excited to see what custom Hooks the React community will come up with.

>Detailed Explanation
>
>You can learn more about custom Hooks on a dedicated page: [Building Your Own Hooks](/docs/hooks-custom.html).

## ๐ Other Hooks {#other-hooks}

There are a few less commonly used built-in Hooks that you might find useful. For example, [`useContext`](/docs/hooks-reference.html#usecontext) lets you subscribe to React context without introducing nesting:

```js{2,3}
function Example() {
  const locale = useContext(LocaleContext);
  const theme = useContext(ThemeContext);
  // ...
}
```

And [`useReducer`](/docs/hooks-reference.html#usereducer) lets you manage local state of complex components with a reducer:

```js{2}
function Todos() {
  const [todos, dispatch] = useReducer(todosReducer);
  // ...
```

>Detailed Explanation
>
>You can learn more about all the built-in Hooks on a dedicated page: [Hooks API Reference](/docs/hooks-reference.html).

## Next Steps {#next-steps}

Phew, that was fast! If some things didn't quite make sense or you'd like to learn more in detail, you can read the next pages, starting with the [State Hook](/docs/hooks-state.html) documentation.

You can also check out the [Hooks API reference](/docs/hooks-reference.html) and the [Hooks FAQ](/docs/hooks-faq.html).

Finally, don't miss the [introduction page](/docs/hooks-intro.html) which explains *why* we're adding Hooks and how we'll start using them side by side with classes -- without rewriting our apps.
